/////////////////////////////////////////////////////////////////////////////
// geodesic.cs
// Geodesic routines
/////////////////////////////////////////////////////////////////////////////
//
// This is a C# portation of an implementation in C of the geodesic algorithms
// described in: C. F. F. Karney, Algorithms for geodesics, J. Geodesy 87, 43--55 (2013)
//   DOI: 10.1007/s00190-012-0578-z
//   addenda: http://geographiclib.sf.net/geod-addenda.html.
//
// The principal advantages of these algorithms over previous ones (e.g.,
// Vincenty, 1975) are
// - accurate to round off for |f|<1/50;
// - the solution of the inverse problem is always found;
// - differential and integral properties of geodesics are computed.
//
// The shortest path between two points on the ellipsoid at (lat1,
// lon1) and (lat2, lon2) is called the geodesic. Its length is
// s12 and the geodesic from point 1 to point 2 has forward azimuths
// azi1 and azi2 at the two end points.
//
// Traditionally two geodesic problems are considered:
// - the direct problem -- given lat1, lon1, s12, and azi1, determine lat2,
//   lon2, and azi2. This is solved by the function geod_direct().
// - the inverse problem -- given lat1, lon1, and lat2, lon2, determine s12,
//   azi1, and azi2. This is solved by the function geod_inverse().
//
// The ellipsoid is specified by its equatorial radius a (typically in
// meters) and flattening f. The routines are accurate to round off with
// double precision arithmetic provided that |f|<1/50; for the WGS84 ellipsoid,
// the errors are less than 15 nanometers. (Reasonably accurate results
// are obtained for |f|<1/5.) For a prolate ellipsoid, specify f<0.
//
// The routines also calculate several other quantities of interest
// - S12 is the area between the geodesic from point 1 to point 2 and the
//   equator; i.e., it is the area, measured counter-clockwise, of the
//   quadrilateral with corners (lat1, lon1), (0, lon1), (0, lon2),
//   and (lat2, lon2).
// - m12, the reduced length of the geodesic is defined such that if
//   the initial azimuth is perturbed by dazi1 (radians) then the
//   second point is displaced by m12 dazi1 in the direction
//   perpendicular to the geodesic. On a curved surface the reduced
//   length obeys a symmetry relation, m12+m21=0. On a flat
//   surface, we have m12=s12.
// - M12 and M21 are geodesic scales. If two geodesics are
//   parallel at point 1 and separated by a small distance dt, then
//   they are separated by a distance M12 dt at point 2. M21
//   is defined similarly (with the geodesics being parallel to one
//   another at point 2). On a flat surface, we have M12=M21=1.
// - a12 is the arc length on the auxiliary sphere. This is a
//   construct for converting the problem to one in spherical
//   trigonometry. a12 is measured in degrees. The spherical arc
//   length from one equator crossing to the next is always 180deg.
//
// If points 1, 2, and 3 lie on a single geodesic, then the following
// addition rules hold:
// - s13=s12+s23
// - a13=a12+a23
// - S13=S12+S23
// - m13=m12*M23+m23*M21
// - M13=M12*M23-(1-M12*M21)*m23/m12
// - M31=M32*M21-(1-M23*M32)*m12/m23
//
// The shortest distance returned by the solution of the inverse problem is
// (obviously) uniquely defined.  However, in a few special cases there are
// multiple azimuths which yield the same shortest distance. Here is a
// catalog of those cases:
// - lat1=-lat2 (with neither point at a pole). If azi1=azi2,
//   the geodesic is unique. Otherwise there are two geodesics
//   and the second one is obtained by setting [azi1, azi2]=[azi2, azi1],
//   [M12, M21]=[M21, M12], S12=-S12. (This occurs when the longitude difference
//   is near +/-180deg for oblate ellipsoids.)
// - lon2=lon1+/-180deg (with neither point at a pole).
//   If azi1=0deg or +/-180deg, the geodesic is unique.
//   Otherwise there are two geodesics and the second one is obtained by
//   setting [azi1, azi2]=[-azi1, -azi2], S12=-S12. (This occurs when lat2 is
//   near -lat1 for prolate ellipsoids.)
// - Points 1 and 2 at opposite poles. There are infinitely many geodesics which
//   can be generated by setting [azi1, azi2]=[azi1, azi2]+[d, -d],
//   for arbitrary d. (For spheres, this prescription applies when points 1 and
//   2 are antipodal.)
// - s12=0 (coincident points). There are infinitely many geodesics which can be
//   generated by setting [azi1, azi2]=[azi1, azi2]+[d, d], for arbitrary d.
//
// These routines are a simple transcription of the corresponding C++ classes
// in GeographicLib (http://geographiclib.sf.net). The "class data" is 
// represented by the structs geod_geodesic, geod_geodesicline,
// geod_polygon and pointers to these objects are passed as initial arguments
// to the member functions. Most of the internal comments have been retained.
// However, in the process of transcription some documentation has been lost
// and the documentation for the C++ classes, GeographicLib::Geodesic,
// GeographicLib::GeodesicLine, and GeographicLib::PolygonAreaT, should be
// consulted. The C++ code remains the "reference implementation". Think
// twice about restructuring the internals of the C code since this may make
// porting fixes from the C++ code more difficult.
//
// Copyright (c) Charles Karney (2012-2015) <charles@karney.com> and licensed
// under the MIT/X11 License. For more information, see
// http://geographiclib.sourceforge.net/
//
// This library was distributed with GeographicLib 1.43.
/////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;

namespace Free.Ports.Proj4.Geodesic
{
	public abstract class geodesic
	{
		#region Version
		/// <summary>
		/// The major version of the geodesic library. (This tracks the version of GeographicLib.)
		/// </summary>
		public const int GEODESIC_VERSION_MAJOR=1;

		/// <summary>
		/// The minor version of the geodesic library. (This tracks the version of GeographicLib.)
		/// </summary>
		public const int GEODESIC_VERSION_MINOR=43;

		/// <summary>
		/// The patch level of the geodesic library. (This tracks the version of GeographicLib.)
		/// </summary>
		public const int GEODESIC_VERSION_PATCH=0;

		/// <summary>
		/// Pack the version components into a single integer. Users should not rely on
		/// this particular packing of the components of the version number; see the
		/// documentation for GEODESIC_VERSION, below.
		/// </summary>
		/// <param name="a">The major version number.</param>
		/// <param name="b">The minor version number.</param>
		/// <param name="c">The patch level.</param>
		/// <returns>The packed version.</returns>
		public static int GEODESIC_VERSION_NUM(int a, int b, int c) { return (((a*10000+b)*100)+c); }

		/// <summary>
		/// The version of the geodesic library as a single integer, packed as MMmmmmpp
		/// where MM is the major version, mmmm is the minor version, and pp is the
		/// patch level.
		/// </summary>
		/// <remarks>
		/// Users should not rely on this particular packing of the components of 
		/// the version number. Instead they should use a test such as
		/// <code>
		/// if(GEODESIC_VERSION>=GEODESIC_VERSION_NUM(1, 40, 0))
		/// </code>
		/// </remarks>
		public static readonly int GEODESIC_VERSION=GEODESIC_VERSION_NUM(GEODESIC_VERSION_MAJOR, GEODESIC_VERSION_MINOR, GEODESIC_VERSION_PATCH);
		#endregion

		#region Const and static readonly
		protected const int GEOGRAPHICLIB_GEODESIC_ORDER=6;
		protected const int nA1=GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nC1=GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nC1p=GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nA2=GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nC2=GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nA3=GEOGRAPHICLIB_GEODESIC_ORDER;
		//protected const int nA3x=nA3;
		protected const int nC3=GEOGRAPHICLIB_GEODESIC_ORDER;
		//protected const int nC3x=((nC3*(nC3-1))/2);
		protected const int nC4=GEOGRAPHICLIB_GEODESIC_ORDER;
		//protected const int nC4x=((nC4*(nC4+1))/2);

		protected const int digits=53; // Number of bits in the mantissa of a double
		protected const double epsilon=2.2204460492503131e-16; // Distance between 1 and the next number storeable in a double (1.0+epsilon!=1.0)
		protected const double realmin=double.Epsilon; // The smallest number bigger than zero
		protected const double pi=Math.PI;
		protected const int maxit1=20;
		protected const int maxit2=maxit1+digits+10;

		protected static readonly double tiny=Math.Sqrt(realmin);
		protected const double tol0=epsilon;

		// Increase multiplier in definition of tol1 from 100 to 200 to fix inverse case
		// 52.784459512564 0 -52.784459512563990912 179.634407464943777557
		// which otherwise failed for Visual Studio 10 (Release and Debug)
		protected const double tol1=200*tol0;
		protected static readonly double tol2=Math.Sqrt(tol0);

		// Check on bisection interval.
		protected static readonly double tolb=tol0*tol2;
		protected static readonly double xthresh=1000*tol2;

		protected const double degree=pi/180;

		protected static readonly double NaN=double.NaN;
		#endregion

		protected static double sq(double x) { return x*x; }

		protected static double log1px(double x)
		{
			double y=1+x;
			double z=y-1;

			// Here's the explanation for this magic: y = 1 + z, exactly, and z
			// approx x, thus log(y)/z (which is nearly constant near z = 0) returns
			// a good approximation to the true log(1 + x)/x. The multiplication x *
			// (log(y)/z) introduces little additional error.
			return z==0?x:x*Math.Log(y)/z;
		}

		protected static double atanhx(double x)
		{
			double y=Math.Abs(x); // Enforce odd parity
			y=log1px(2*y/(1-y))/2;
			return x<0?-y:y;
		}

		protected static double hypotx(double x, double y) { return Math.Sqrt(x*x+y*y); }

		protected static double cbrtx(double x)
		{
			double y=Math.Pow(Math.Abs(x), 1.0/3); // Return the real cube root
			return x<0?-y:y;
		}

		protected static double sumx(double u, double v, out double t)
		{
			double s=u+v;
			double up=s-v;
			double vpp=s-up;

			up-=u;
			vpp-=v;
			t=-(up+vpp);

			// error-free sum:
			// u + v =       s      + t
			//       = round(u + v) + t
			return s;
		}

		protected static double polyval(int N, double[] p, double x)
		{
			double y=0;
			for(int i=0; i<=N; i++) y=y*x+p[i];
			return y;
		}

		protected static double polyval(int N, double[] p, int offset, double x)
		{
			double y=0;
			for(int i=0; i<=N; i++) y=y*x+p[i+offset];
			return y;
		}

		protected static double minx(double x, double y) { return x<y?x:y; }

		protected static double maxx(double x, double y) { return x>y?x:y; }

		protected static void swapx(ref double x, ref double y) { double t=x; x=y; y=t; }

		protected static void norm2(ref double sinx, ref double cosx)
		{
			double r=hypotx(sinx, cosx);
			sinx/=r;
			cosx/=r;
		}

		protected static double AngNormalize(double x) { return x>=180?x-360:(x<-180?x+360:x); }
		protected static double AngNormalize2(double x) { return AngNormalize(x%360.0); }

		protected static double AngDiff(double x, double y)
		{
			double t;
			double d=sumx(-x, y, out t);

			if((d-0180.0)+t>0.0)		// y - x > 180
				d-=360.0;				// exact
			else if((d+180.0)+t<=0.0)	// y - x <= -180
				d+=360.0;				// exact

			return d+t;
		}

		protected static double AngRound(double x)
		{
			const double z=1.0/16;
			double y=Math.Abs(x);

			// The compiler mustn't "simplify" z - (z - y) to y
			y=y<z?z-(z-y):y;
			return x<0?0-y:y;
		}

		protected static double SinCosSeries(bool sinp, double sinx, double cosx, double[] c, int n)
		{
			// Evaluate
			// y=sinp?sum(c[i]*sin( 2*i   *x), i, 1, n):
			//        sum(c[i]*cos((2*i+1)*x), i, 0, n-1)
			// using Clenshaw summation. N.B. c[0] is unused for sin series
			// Approx operation count=(n+5) mult and (2*n+2) add
			int i=(n+(sinp?0:1)); // Point to one beyond last element
			double ar=2*(cosx-sinx)*(cosx+sinx); // 2*cos(2*x)
			double y0=((n&1)!=0)?c[--i]:0, y1=0; // accumulators for sum

			// Now n is even
			n/=2;
			while(n--!=0)
			{
				// Unroll loop x 2, so accumulators return to their original role
				y1=ar*y0-y1+c[--i];
				y0=ar*y1-y0+c[--i];
			}
			return sinp?
				2*sinx*cosx*y0: // sin(2*x)*y0
				cosx*(y0-y1); // cos(x)*(y0-y1)
		}
	}
}
